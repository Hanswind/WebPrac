# 11. 리액트 최적화 작업

#### [1. 많은 데이터 렌더링하기]

-----

: 만약 TodoList가 몇천개가 되면.. (작업 처리되는데 너무 느림)

: 개발자 도구 - performance - stop 버튼 - 성능분석 시간 Timings - hover 처리되는데 1.02초 (매우느린 속도..)

<br>

#### [2. 컴퓨터가 느려지는 원인 분석]

----

: 컴포넌트가 리렌더링 발생하는 상황

1. **전달받은 props가 변경될때**

2. **자신의 state가 바뀔때**
3. **부모 컴포넌트가 리렌더링될때**
4. **forceUpdate 함수가 실행될때**

: 여기서는 '할일1' 항목 체크하면 App의 state가 변경되며 App 컴포넌트가 리렌더링.

: 부모 컴포넌트가 리렌더링 되고 그 안의 무수한 컴포넌트들도 리렌더링된다.

: **여기서 '할일1' 리렌더링해야되지만 나머지 2 ~ 2500까지는 리렌더링 안해도 되는 상황..**

: **불필요한 리렌더링 방지해야한다**

<br>

#### [3. 최적화작업1 - React.memo를 사용해 컴포넌트 성능 최적화]

-----

: **컴포넌트 리렌더링 방지 위해 shouldComponentUpdate 라이프사이클 사요하면 된다**

: **함수형 컴포넌트에서는 대신 React.memo 함수 사용**

- **React.memo** : 컴포넌트의 props가 바뀌지 않았다면, 리렌더링 않도록 설정하는 작업

```react
// TodoListItem.js
...
export default React.memo(TodoListItem);
```

: **이제 TodoListItem 컴포넌트는 todo, onRemove, onToggle이 바뀌지 않으면 리렌더링 하지 않는다.**

<br>

#### [4. 최적화작업2 - onToggle, onREmove 함수가 바뀌지 않게 하기]

----

: 현재 onToggle, onRemove 함수는 배열 상태 업데이트하며 최신 상태의 todos를 참조하기 위해, todos 배열 바뀔때 함수가 새로생성됨.

- **이를 예방하는 방법**

  1. useState의 함수형 업데이트 기능 사용하는 방법
  2. useReducer 사용하는 방법

  <br>

1. **useState의 함수형 업데이트 기능 사용하는 방법**

   : 기존에 setTodos 함수 사용할때 새로운 상태를 파라미터로 넣어 줬었음.

   : **대신, 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣어주는 방법으로 변경 ( = 함수형 업데이트)**

   ```react
   const [number, setNumber] = useState(0);
   
   // 기존
   setNumber(number + 1)
   
   // 개선
   const onIncrease = useCallback(
   	() => setNumber(prevNumber => prevNumber + 1),
       [],
   );
   ```

   ```react
   // App.js
   
   // 기존
   setTodos(todos.concat(todo));  // 1. onInsert 함수
   
   setTodos(todos.filter((todo) => todo.id !== id));  // 2. onRemove 함수
   
   setTodos(  // 3. onToggle함수
     todos.map((todo) =>
       todo.id === id ? { ...todo, checked: !todo.checked } : todo
     )
   );
   
   
   // 개선
   setTodo(todos => todos.concat(todo))
   setTodos(todos => todos.filter((todo) => todo.id !== id));
   setTodos(todos =>
     todos.map((todo) =>
       todo.id === id ? { ...todo, checked: !todo.checked } : todo
     )
   );
   ```

   : **setTodos를 사용할때 그 안에 todos =>  만 넣어주면 된다!**

   <br>

2. **useReducer 사용하는 방법**

   : useState 대신 useReducer 사용해도 onToggle과 onRemove가 계속 새로워지는 문제 해결 가능

   ```js
   // App.js
   ...
   import ... {useReducer ...} from "react";
   ...
   
   // 삽입, 제거, 토글 행위 처리하는 함수
   function todoReducer(todos, action) {
     switch (action.type) {
       case "INSERT": // 새로추가
         // { type : 'INSERT', todo : { id : 1, text : 'todo', checked : false }}
         return todos.concat(action.todo);
   
       case "REMOVE": // 제거
         return todos.filter((todo) => todo.id !== action.id);
   
       case "TOGGLE":
         return todos.map((todo) =>
           todo.id === action.id ? { ...todo, checked: !todo.checked } : todo
         );
   
       default:
         return todos;
     }
   }
   ```

   ```react
   // const [todos, setTodos] = useState(createBulkTodos);
     const [todos, dispatch] = useReducer(todoReducer, undefined, createBulkTodos);
   
     // 고유값으로 사용될 id - ref 사용
     const nextId = useRef(2501);
   
     const onInsert = useCallback((text) => {
       const todo = {
         id: nextId.current,
         text,
         checked: false,
       };
   
       //setTodos((todos) => todos.concat(todo));
       dispatch({ type: "INSERT", todo });
       nextId.current += 1;
     }, []);
   
   
   
     // 주어진 id 값으로 todo 지우는 함수
     const onRemove = useCallback((id) => {
       //setTodos((todos) => todos.filter((todo) => todo.id !== id));
       dispatch({ type: "REMOVE", id });
     }, []);
   
   
   
     // 작성한 내용 수정 기능 함수
     const onToggle = useCallback((id) => {
       //setTodos((todos) =>
       //  todos.map((todo) =>
       //    todo.id === id ? { ...todo, checked: !todo.checked } : todo
       //  )
       //);
       dispatch({ type: "TOGGLE", id });
     }, []);
   ```

   