# 35. 정규표현식

: 정교한 문자열 매칭 기능을 제공.

ex) 이메일주소, URI, 전화번호 와 같은 문자열 검색 원할시 주로 사용

: 정규식이라고도 함

<br>

#### [1. 부분문자열 검색과 대체]

---

- 정규식을 사용하지 않고 부분 문자열 검색 하는 방법 - **String.prototype 메서드**

    ```js
    const input = "As I was going to Saint Ives";
    input.startsWith("As");  // true
    input.endsWith("Ives");  // true
    input.startsWith("going", 9)  // true -- 인덱스 9에서 시작.
    input.endsWith("going", 14)  // true -- 인덱스 14를 문자열의 끝으로 간주.

    input.includes("going")      // true
    input.includes("going")       // false -- 인덱스 10에서 시작해서 포함여부

    input.indexOf("going")        // 9
    input.indexOf("going", 10)    // -1
    input.indexOf("nope")         // -1
    ```

    ```js
    // 대소문자 구분 안하고 비교하는 법
    input.toLowerCase().startsWith("as")    // true
    ```

    ```js
    // 부분 문자열 교체 - String.prototype.replace
    const output = input.replace("going", "walking");
    ```

<br>

#### [2. 정규식 만들기]

---

: **RegExp** 생성자 사용해 정규식 만들수 있지만 **간단한 리터럴 문법**도 존재

```js
const re1 = /going/;   // 단어 "going" 찾을수 있는 정규식
const re2 = new RegExp("going");  // 생성자 사용했지만 결과는 동일
```

<br>

#### [3. 정규식 검색]

----

```js
문자열.match(정규식);    // 정규식에 해당되는 문자들이 배열 형태로 출력
문자열.search(정규식);   // 해당 정규식에 해당되는 첫 단어의 인덱스 출력

// 해당되는 문자열을 일치하는 순서대로 출력(단일배열형태). 더이상 없으면 null 출력
정규식.exec(문자열);
정규식.exec(문자열);
정규식.exec(문자열);
...

정규식.test(input);     // 하나 이상 있으면 true 출력
```

```js
// 정규식 검색 예제
const input = "As I was going to Saint Ives"
const re = /\w{3.}/ig;    // 세 글자 이상인 단어에 모두 일치

input.match(re);   // ["was", "going", "Saint", "Ives"]
input.serach(re);  // 5

re.exec(input);    // ["was"]
re.exec(input);    // ["going"]
re.exec(input);    // ["Saint"]
re.exec(input);    // ["Ives"]
re.exec(input);    // null

re.test(input);    // true
```

<br>

#### [4. 정규식을 사용한 문자열 교체]

----

: 위에서 봤던 String.prototype.replace 메서드를 정규식에 사용

```js
// ex) 4글자 이상으로 이루어진 단어를 모두 **** 으로 교체
const output = input.replace(/\w{4.}/ig, '****');
```

<br>

#### [5. 입력 소비]

-----

: 정규식을 단순히 부분문자열을 찾는 방법이라 생각하지 X.

: 정규식은 **입력 문자열을 소비하는 패턴**이라고 생각하기.

: 소비하다 = 정규식 엔진이 해당사항이 없어 지나간 경우. 글자를 소비했다고 표현.

- **정규식 문자열 소비에 사용하는 일고리즘**
  - 문자열 왼쪽에서 오른쪽으로 진행
  - 일단 소비한 글자로 다시 되돌아 오는 경우 X
  - 한번에 한글자씩 움직이면 일치여부 확인
  - 일치시, 해당글자를 한꺼번에 소비한후 다음 글자로 진행.
  - 이보다 세밀한 알고리즘 존재... 나중에.

<br>

#### [6. 대체]

----

: **alternation. 여러 해당 사항을 찾는 방법**

```js
const html = 'HTML with <a href="/one">one line</a>, and some JavaScript. ' + 
	'<script src="stuff.js">';
	
const matches = html.match(/area|a|link|script|source/ig);
// 텍스트에서 area, a, link, script, source를 대소문자 가리지 않고 모두 찾으라는 뜻
```

- **파이프(|) 는 대체를 뜻하는 메타 문자**

-  **ig**는 대소문자 가리지 않고(i) 전체(g) 를 검색하라는 의미

-  **area를 a보다 먼저쓴 이유 **

  : 정규식이 왼쪽부터 오른쪽으로 평가하기 때문

  : a를 area보다 먼저 쓰면, 텍스트에 area 있어도 a를 먼저 소비해 남는 rea는 어느것에도 일치 X

  : 작은걸 먼저 쓰면 절대 찾을수 없다.

<br>

#### [7.HTML 찾기]

---

: 위 방식으로 HTML 태그 찾을수도 있지만 의도지 않는 예외 경우 많이 발생할수 있다.

ex) 위 예제에서는 HTML 태그 아닌 a도 나오는 등의 에러. (글자데이터(CDATA))

: 그렇다고 다른 방법 ? 없음.

: **정규식 자체가 HTML처럼 매우 복잡한 것을 검색하기에 알맞지 않다**

<br>

#### [8. 문자셋]

----

: **글자 하나를 다른 것으로 대체하는 방법을 간단하게 줄인 것**

```js
// 문자셋 예제 - 문자열에 있는 숫자 찾기

// 이렇게 쓰면 불편.. 문자셋 이용하면(범위 지원) 더 간략하게 표시 가능
const matches = 문자열.match(/0|1|2|3|4|5|6|7|8|9/g;   

// 문자셋 범위 사용한 표현
const m1 = 문자열.match(/[0123456789]/g);
const m2 = 문자열.match(/[0-9]/g);
```

```js
// 문자셋 이용해 글자와 숫자, 기타 구두점을 찾기 (공백빼고 다 찾기)
const match = 문자열.match(/[\-0-9a-z.]/);

// 공백만 찾기
const match = 문자열.match(/[^\-0-9a-z.]/);
```

<br>

#### [9. 자주쓰는 문자셋]

---

: 매우 자주 사용되는 일부 문자셋은 단축 표기가 따로 존재. 

: **클래스**라고도 함

| 문자셋 | 동등한 표현  |                노트                |
| :----: | :----------: | :--------------------------------: |
|   \d   |    [0-9]     |                                    |
|   \D   |    [^0-9]    |                                    |
|   \s   | [ \t\v\n\r]  | 탭, 스페이스, 세로 탭, 줄바꿈 포함 |
|   \S   | [^ \t\v\n\r] |                                    |
|   \w   |  [a-zA-Z_]   |      하이픈과 마침표는 포함 X      |
|   \W   |  [^a-zA-Z_]  |                                    |

: \D, \S, \W를 적절히 사용하면 원치 않는 문자를 빠르고 효율적으로 제거 가능 (ex. 전화번호형식통일)

```js
// 클래스 예제

// 1. 공백을써서 줄 맞추기
const levels = 문자열.match(/:\s*[0-9]/g);  // \s뒤의 *는 '숫자는 상관없으며 없어도된다는 뜻'

// 2. 전화번호 형식 맞추기 - 10자리 숫자형태로
const neatPhone = 전화번호.replace(/\D/g, '');  // 숫자아닌건 공백으로

// 3. \S이용해 required 필드에 데이터 유무 검색
const vaild = /\S/.test(문자열);
```

<br>

#### [10. 반복]

----

: **얼마나 많이 일지해야하는지 지정할때 사용**

```js
// 반복 예제 - ex) 숫자 여러개 찾기..
const match = 문자열.match(/[0-9][0-9][0-9][0-9][0-9]/);

// 반복 이용해 개선
const match = 문자열.match(/[0-9]+ /);  // 문자셋 다음의 +는 그 앞의 요소가 하나 이상 있다는뜻
```

- **반복 메타 문자 5가지 종류**

  | 반복 메타 문자 | 설명                   | 예제                                                     |
  | -------------- | ---------------------- | -------------------------------------------------------- |
  | {n}            | 정확히 n개             | /\d{5}/ : 정확히5자리 숫자                               |
  | {n, }          | 최소한 n개             | /\d{5, }/ : 5자리 이상의 숫자에 일치                     |
  | {n, m}         | n개 이상, m개 이하     | /d{2,5}/ : 2,3,4,5개에 일치                              |
  | ?              | 0 or 1개. {0,1}와 동일 | /[a-z]\d?/i : 글자있고 그다음에 숫자가 없거나 한개있을때 |
  | *              | 있든 없든 상관 무      | /[a=z]\d*/i : 글자뒤에 숫자있든 없든 일치                |
  | +              | 하나이상               | /[a=z]\d*/i : 글자뒤에 숫자 한개 이상일때 일치           |

<br>

#### [마침표와 이스케이프]

----

