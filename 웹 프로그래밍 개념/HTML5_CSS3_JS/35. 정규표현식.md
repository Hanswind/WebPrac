# 35. 정규표현식

: 정교한 문자열 매칭 기능을 제공.

ex) 이메일주소, URI, 전화번호 와 같은 문자열 검색 원할시 주로 사용

: 정규식이라고도 함

<br>

#### [1. 부분문자열 검색과 대체]

---

- 정규식을 사용하지 않고 부분 문자열 검색 하는 방법 - **String.prototype 메서드**

    ```js
    const input = "As I was going to Saint Ives";
    input.startsWith("As");  // true
    input.endsWith("Ives");  // true
    input.startsWith("going", 9)  // true -- 인덱스 9에서 시작.
    input.endsWith("going", 14)  // true -- 인덱스 14를 문자열의 끝으로 간주.

    input.includes("going")      // true
    input.includes("going")       // false -- 인덱스 10에서 시작해서 포함여부

    input.indexOf("going")        // 9
    input.indexOf("going", 10)    // -1
    input.indexOf("nope")         // -1
    ```

    ```js
    // 대소문자 구분 안하고 비교하는 법
    input.toLowerCase().startsWith("as")    // true
    ```

    ```js
    // 부분 문자열 교체 - String.prototype.replace
    const output = input.replace("going", "walking");
    ```

<br>

#### [2. 정규식 만들기]

---

: **RegExp** 생성자 사용해 정규식 만들수 있지만 **간단한 리터럴 문법**도 존재

```js
const re1 = /going/;   // 단어 "going" 찾을수 있는 정규식
const re2 = new RegExp("going");  // 생성자 사용했지만 결과는 동일
```

<br>

#### [3. 정규식 검색]

----

```js
문자열.match(정규식);    // 정규식에 해당되는 문자들이 배열 형태로 출력
문자열.search(정규식);   // 해당 정규식에 해당되는 첫 단어의 인덱스 출력

// 해당되는 문자열을 일치하는 순서대로 출력(단일배열형태). 더이상 없으면 null 출력
정규식.exec(문자열);
정규식.exec(문자열);
정규식.exec(문자열);
...

정규식.test(input);     // 하나 이상 있으면 true 출력
```

```js
// 정규식 검색 예제
const input = "As I was going to Saint Ives"
const re = /\w{3.}/ig;    // 세 글자 이상인 단어에 모두 일치

input.match(re);   // ["was", "going", "Saint", "Ives"]
input.serach(re);  // 5

re.exec(input);    // ["was"]
re.exec(input);    // ["going"]
re.exec(input);    // ["Saint"]
re.exec(input);    // ["Ives"]
re.exec(input);    // null

re.test(input);    // true
```

<br>

#### [4. 정규식을 사용한 문자열 교체]

----

: 위에서 봤던 String.prototype.replace 메서드를 정규식에 사용

```js
// ex) 4글자 이상으로 이루어진 단어를 모두 **** 으로 교체
const output = input.replace(/\w{4.}/ig, '****');
```

<br>

#### [5. 입력 소비]

-----

: 정규식을 단순히 부분문자열을 찾는 방법이라 생각하지 X.

: 정규식은 **입력 문자열을 소비하는 패턴**이라고 생각하기.

: 소비하다 = 정규식 엔진이 해당사항이 없어 지나간 경우. 글자를 소비했다고 표현.

- **정규식 문자열 소비에 사용하는 일고리즘**
  - 문자열 왼쪽에서 오른쪽으로 진행
  - 일단 소비한 글자로 다시 되돌아 오는 경우 X
  - 한번에 한글자씩 움직이면 일치여부 확인
  - 일치시, 해당글자를 한꺼번에 소비한후 다음 글자로 진행.
  - 이보다 세밀한 알고리즘 존재... 나중에.

<br>

#### [6. 대체]

----

: **alternation. 여러 해당 사항을 찾는 방법**

```js
const html = 'HTML with <a href="/one">one line</a>, and some JavaScript. ' + 
	'<script src="stuff.js">';
	
const matches = html.match(/area|a|link|script|source/ig);
// 텍스트에서 area, a, link, script, source를 대소문자 가리지 않고 모두 찾으라는 뜻
```

- **파이프(|) 는 대체를 뜻하는 메타 문자**

-  **ig**는 대소문자 가리지 않고(i) 전체(g) 를 검색하라는 의미

-  **area를 a보다 먼저쓴 이유 **

  : 정규식이 왼쪽부터 오른쪽으로 평가하기 때문

  : a를 area보다 먼저 쓰면, 텍스트에 area 있어도 a를 먼저 소비해 남는 rea는 어느것에도 일치 X

  : 작은걸 먼저 쓰면 절대 찾을수 없다.

<br>

#### [7.HTML 찾기]

---

: 위 방식으로 HTML 태그 찾을수도 있지만 의도지 않는 예외 경우 많이 발생할수 있다.

ex) 위 예제에서는 HTML 태그 아닌 a도 나오는 등의 에러. (글자데이터(CDATA))

: 그렇다고 다른 방법 ? 없음.

: **정규식 자체가 HTML처럼 매우 복잡한 것을 검색하기에 알맞지 않다**

<br>



