# 23. 스코프

: 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정한다.

<br>

#### [스코프의 대표적 예제]

----

```js
function f(x){
	return x + 3;
}
f(5);  // 8
x;     // x is not defined
```

<br>

#### [스코프와 존재]

----

- **스코프** : 가시성. 현재 실행중인 부분에서 보이고 접근할 수 있는 직별자
- **존재** : 식별자가 메모리가 할당된 무언가를 가르키고 있을때 존재한다는 것.
  - 더이상 존재 하지않는다해서 바로 메모리에서 회수되는게 아니라 주기적으로 일어나는 **가비지 콜렉션 프로세스에서 메모리를 회수**

```js
const x = 3;

function f() {
	const x = 5;    // x = 3인건 존재하지만 비가시성으로 변환된다.
	return x;
}

f();  // 5
x;   // 3  ,  존재하지 않게된 위의 x = 5는 가비지 콜렉션 일어나면 공간 회수된다.
```

<br>

#### [정적 스코프와 동적 스코프]

----

- **정적 스코프** : 단순히 위에서 아래로 읽어내리는 문의 연속
- **동적 스코프** : 프로그램 내 코드의 실행 순서에 따라 적용되는 문
- **자바스크립트는 정적 스코프 방식**

<br>

#### [전역 스코프]

----

: 프로그램을 실행할때 주어지는 암시적인 스코프

: 남용 X

```js
// 전역 스코프에 변수 선언
let name = "Irena";
let age = 25;

function greet(){
    console.log("Hello, ${name}!");
}

function getBirthYear(){
    return new Date().getFullYear() - age;
}
```

```js
// 개선된 모습 : 사용자 정보를 단일 객체에 보관하는 방법	
let user = {
    name = "Irena",
    age = 25,
};
...
```

: 프로그램이 커지며 모든 스코프를 기억하고 관리할 수 없게된다면 전역 스코프에 의존 X 가 중요!

<br>

#### [블록 스코프]

----

: **let, const는 식별자를 블록 스코프에서 선언한다**

: 즉, 해당 블록 나가면 정의되지 않은것으로 간주

<br>

#### [변수 숨기기]

-----

: 내부 블록에서 동의한 변수명으로 정의하면 외부 스코프의 해당 변수를 숨기는 효과가 있다.

<br>

#### [함수, 클로저, 정적 스코프]

----

- **클로저** : 함수가 특정 스코프에 접근할 수있도록 의도적으로 그 스코프에서 정의하는 경우

  = 스코프 안에서 함수를 정의하면 스코프는 더 오래 유지된다.

  ```js
  // 보통 클로저 예시
  let globalFunc;            // 정의 되지 않은 전역 함수
  {
      let blockVar = 'a';    // 블록 스코프에 있는 변수
      globalFunc = function(){
          console.log(bloackVar);
      }
  }
  globalFunc();              // "a"
  ```

  : globalFunc가 블록 안에서 값을 할당 받았지만, 어디서 호출되든 이 함수는 클로저에 들어있는 식별자에 접근 할수 있다.

  ```js
  // 클로저 사용하면 지역 변수(지역 스코프) 사용 가능
  let f;
  {
  	let o = {note : "Safe"};
      f = function() {
          return o;
      }
  }
  lef oRef = f();
  oRef.note = "Not so safe";
  ```

  : 이와 같은 형태도 가능

  ```js
  // 해당 클로저를 사용해 지역 변수 값을 변경하면 이후 호출해도 변경된 값으로 적용되어있다.
  ```

  <br>

#### [즉시 호출 함수 표현식 = IIFE]

----

: **IIFE는 함수를 선언하고 즉시 실행한다.**

```js
// IIFE의 기본 형태
(function() {
	// IIFE 바디
})
```

: 함수 표현식을 **익명** 함수로 만들고 그 함수 즉시 호출

: **내부에 있는 것들이 모두 자신만의 스코프를 가지지만, 함수이므로, 그 스코프 밖으로 무언가를 내보낼수 있다**는 장점이 있다.

<br>

**[IIFE의 장점 예시]**

 1. 변수 secret은 IIFE 스코프 안에서 안전하게 보호, 외부서 접근 불가능

    ```js
    const message = (function() {
    	const secret = "I'm a secret!";
    	return 'the secret is ${secret.length} characters long.';
    })();
    console.log(message);
    ```

2. 자신이 몇번 호출되었는지 저장한 값을 외부에서 절대 손댈 수 없다.

   ```js
   const f = (function() {
       let count = 0;
       return function() {
           return '${++count} 번 호출된 함수입니다.';
       }(
   }))();
   f();  // "1번 호출된 함수입니다."
   f();  // "2번 호출된 함수입니다."
   ```

   : ES6에서 블록 스코프 변수(const, let) 도입되면서 IIFE 필요한 경우 많이 줄기는 했지만 여전히 널리 사용된다.

   : 클로저 만들고 클러저에서 무언가 반환받을때 유용히 사용가능

   <br>

#### [함수 스코프와 호이스팅]

-----

: ES6 let 도입 이전, **var 써서 선언한 변수들은 함수 스코프**를 가짐.

: let으로 변수 선언시, 그 변수는 선언하기 전에 존재 X

: **var변수는 현재 스코프 안이라면 어디서든 사용 가능. (선언전에도 사용 가능)**

```js
x;   // x정의 안됨 오류
let x = 3;

x;  // undefined
var x = 3;
x;  // 3
```

: 이때 중요한건, **선언하기전에 해당 변수를 undefined로 사용 가능하다는 것.**

<br>

**[함수 스코프 문제점]**

: 변수를 선언하기도 전에 사용하면 문제, 에러에 취약

: var 변수 이후 ES6에서 let 변수를 새로 만든 이유중 하나

<br>

#### [함수 호이스팅]

----

: 위의 함수 스코프와 같이 **함수 선언도 스코프 맨 위로** 끌어올려진다.

: **함수를 선언전에 호출 가능**

```
f();    // 'f'
function f() {
  console.log('f');
}
```

<br>

#### [사각지대]

----

: let로 선언하는 변수는 선언전에 존재하지 않는다는 직관적 개념을 잘 나타내는 표현

```js
// let 키워드 도입후 사각지대 생기기전 아래와 같은 코드로 존재 확인하는 안전한 방법 존재
if (typeof x === "undefined"){
    console.log("x doesn't exit or is undefined");
} else {
    // x를 사용해도 안전한 코드
}
```

: ES6에서는 이 문제 발생 확인 필요 X

<br>

#### [스트릭트 모드]

----

: ES6이전에 **var로 변수 선언 잊으면, JS는 전역변수 참조하려한다고 간주하고, 해당 전역변수 없으면 스스로 만들었다.**

: 이런 문제때문에 JS에서 **스트릭트 모드(strict mode) 도입**

: 스트릭트 모드에서는 **암시적 전역변수를 허용하지 않는다**

```js
// 스트릭트 모드를 사용하는 방법
(function() {
  "use strict";
  
  // 코드 작성
})();
```

: **전역 스코프에서 "use strict"를 사용하면 적용되고, 특정 함수안에서 쓰면 해당 함수만 적용**

: 단 이 모드 적용하면 **스크립트 전체 동작 방식이 바뀐다**

: 그래서 일반적으로 스트릭트 모드 사용 안하는 편 권장..

<br>

#### [마무리]

-----

자바스크립트의 클로저 널리 유용하게 사용되고 있기에 개발에서 중요한 위치에 존재.