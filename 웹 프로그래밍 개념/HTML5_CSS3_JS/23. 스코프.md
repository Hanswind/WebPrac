# 23. 스코프

: 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정한다.

<br>

#### [스코프의 대표적 예제]

----

```js
function f(x){
	return x + 3;
}
f(5);  // 8
x;     // x is not defined
```

<br>

#### [스코프와 존재]

----

- **스코프** : 가시성. 현재 실행중인 부분에서 보이고 접근할 수 있는 직별자
- **존재** : 식별자가 메모리가 할당된 무언가를 가르키고 있을때 존재한다는 것.
  - 더이상 존재 하지않는다해서 바로 메모리에서 회수되는게 아니라 주기적으로 일어나는 **가비지 콜렉션 프로세스에서 메모리를 회수**

```js
const x = 3;

function f() {
	const x = 5;    // x = 3인건 존재하지만 비가시성으로 변환된다.
	return x;
}

f();  // 5
x;   // 3  ,  존재하지 않게된 위의 x = 5는 가비지 콜렉션 일어나면 공간 회수된다.
```

<br>

#### [정적 스코프와 동적 스코프]

----

- **정적 스코프** : 단순히 위에서 아래로 읽어내리는 문의 연속
- **동적 스코프** : 프로그램 내 코드의 실행 순서에 따라 적용되는 문
- **자바스크립트는 정적 스코프 방식**

<br>

#### [전역 스코프]

----

: 프로그램을 실행할때 주어지는 암시적인 스코프

: 남용 X

```js
// 전역 스코프에 변수 선언
let name = "Irena";
let age = 25;

function greet(){
    console.log("Hello, ${name}!");
}

function getBirthYear(){
    return new Date().getFullYear() - age;
}
```

```js
// 개선된 모습 : 사용자 정보를 단일 객체에 보관하는 방법	
let user = {
    name = "Irena",
    age = 25,
};
...
```

: 프로그램이 커지며 모든 스코프를 기억하고 관리할 수 없게된다면 전역 스코프에 의존 X 가 중요!

<br>

#### [블록 스코프]

----

: **let, const는 식별자를 블록 스코프에서 선언한다**

: 즉, 해당 블록 나가면 정의되지 않은것으로 간주

<br>

#### [변수 숨기기]

-----

: 내부 블록에서 동의한 변수명으로 정의하면 외부 스코프의 해당 변수를 숨기는 효과가 있다.

<br>

#### [함수, 클로저, 정적 스코프]

----

- **클로저** : 함수가 특정 스코프에 접근할 수있도록 의도적으로 그 스코프에서 정의하는 경우

  = 스코프 안에서 함수를 정의하면 스코프는 더 오래 유지된다.

  ```js
  // 보통 클로저 예시
  let globalFunc;            // 정의 되지 않은 전역 함수
  {
      let blockVar = 'a';    // 블록 스코프에 있는 변수
      globalFunc = function(){
          console.log(bloackVar);
      }
  }
  globalFunc();              // "a"
  ```

  : globalFunc가 블록 안에서 값을 할당 받았지만, 어디서 호출되든 이 함수는 클로저에 들어있는 식별자에 접근 할수 있다.

  ```js
  // 클로저 사용하면 지역 변수(지역 스코프) 사용 가능
  let f;
  {
  	let o = {note : "Safe"};
      f = function() {
          return o;
      }
  }
  lef oRef = f();
  oRef.note = "Not so safe";
  ```

  : 이와 같은 형태도 가능

  ```js
  // 해당 클로저를 사용해 지역 변수 값을 변경하면 이후 호출해도 변경된 값으로 적용되어있다.
  ```

  <br>

#### [즉시 호출 함수 표현식 = IIFE]

----

: **IIFE는 함수를 선언하고 즉시 실행한다.**

```js
// IIFE의 기본 형태
(function() {
	// IIFE 바디
})
```

: 함수 표현식을 **익명** 함수로 만들고 그 함수 즉시 호출

: **내부에 있는 것들이 모두 자신만의 스코프를 가지지만, 함수이므로, 그 스코프 밖으로 무언가를 내보낼수 있다**는 장점이 있다.

<br>

**[IIFE의 장점 예시]**

 1. 변수 secret은 IIFE 스코프 안에서 안전하게 보호, 외부서 접근 불가능

    ```js
    const message = (function() {
    	const secret = "I'm a secret!";
    	return 'the secret is ${secret.length} characters long.';
    })();
    console.log(message);
    ```

2. 자신이 몇번 호출되었는지 저장한 값을 외부에서 절대 손댈 수 없다.

   ```js
   const f = (function() {
       let count = 0;
       return function() {
           return '${++count} 번 호출된 함수입니다.';
       }(
   }))();
   f();  // "1번 호출된 함수입니다."
   f();  // "2번 호출된 함수입니다."
   ```

   : ES6에서 블록 스코프 변수(const, let) 도입되면서 IIFE 필요한 경우 많이 줄기는 했지만 여전히 널리 사용된다.

   : 클로저 만들고 클러저에서 무언가 반환받을때 유용히 사용가능

   <br>

#### [함수 스코프와 호이스팅]